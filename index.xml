<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>一个程序员的辩白</title><link>https://leiless.me/</link><description>Recent content on 一个程序员的辩白</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><atom:link href="https://leiless.me/index.xml" rel="self" type="application/rss+xml"/><item><title>2020年终总结</title><link>https://leiless.me/2020-retrospect/</link><pubDate>Fri, 01 Jan 2021 00:00:00 +0000</pubDate><guid>https://leiless.me/2020-retrospect/</guid><description>咳咳，2020年的年终总结的主题是，忆苦思甜。
几年前就有每年写一篇总结的想法，不过由于总总原因被推迟掉了。本质上还是因为太懒了，另外我觉得写博客是一件很费时间的事情。
不过这几天陆续在Twitter上看到一些推友发了他们的年终总结，我停下来重新思考这个问题，逝者如斯，我们大概很难在将来的某个节点清楚地知道自己此刻的心境和想法，因此记录便有了其深层次意义。
前序 在开始正文之前，我觉得有必要提一下我最近看到的 laike9m 发表于2019年的一篇博文 People Die, but Long Live GitHub，节选其中一段：
不知道有没有人注意到，Joe Armstrong 最近几个月都在忙着迁移博客到 TiddlyWiki。我很早就关注了他的 Twitter，然而之前并没多想。听闻大师在 4 月 20 号去世，我才反应过来，原来他之前的举动是在未雨绸缪。&amp;hellip;
重要的是，你把信息存在哪？如果你希望存储一段信息，让 100 年后的人也能访问，要怎么做？&amp;hellip;
所以，我们还有什么选择？想来想去，也只有 GitHub 了。
其实很早之前我就有维护博客系统，不过每次博客都很短命：
没有找到一个比较稳定的方式存储博文，之前存在VPS上，但有时候忘记续费导致数据没了，得重新部署，觉得很麻烦就Delay了很多次。 没有找到一个所见即所得(WYSIWYG)的撰写博文的方式。 不过目前的部署方案 Github Pages + Jekyll 令我很满意（切换到了GitHub Pages + Hugo），基本上解决了上面说到的问题，这样我也许就有动力去写更多文章了。Hooray 🥳
一点点小成就 回到主题，2020年客观原因上，发生了很多事情，影响并改变了每一个人的生活，对我而言，在疫情期间稍微让我欣慰的是，在家办公可以不用加班。这让我稍微有一些时间可以去学一些东西，写一点代码。
现在回想起来，那期间还是稍微有一点小成就的。那时候远程办公最大的障碍大概是家里连公司网络很麻烦，有一些本地应用并不支持设置代理，另外公司内部自有部署DNS，访问那些服务需要走公司的DNS才能正确解析。
另外我还想兼顾DNS隐私的问题，想来想去，最终似乎只有走DNS over HTTPS/TLS，配合上DNS分流才能达到我的目的，偶然情况看到 missdeer/gen_Corefile.sh，发现CoreDNS似乎可以完成我想要的目的。
不过最终发现CoreDNS官方的foward/proxy插件并不能很好地实现我需要的功能，另外，missdeer/gen_Corefile.sh 给出的解决方案我觉得不是太优雅。于是就有了自己写一个简单的CoreDNS插件的想法，顺带还可以运用一些刚学不久的Golang。
倒腾了一阵子，就有了现在的 leiless/dnsredir 项目了。为了将家庭网络配置上透明代理，我了解了DNS协议，写了一个DNS分流插件，学习了如何搭建 trojan-gfw，使用 ipset/iptables。将整个透明代理的脉络拎清。
花了一大段篇幅将这个，想说的是，这个项目虽然简单，但是对我的激励作用是比较大的（可能是我比较菜），那种逐渐清晰的感觉是很能鼓舞人心的。
这为我后面学习，写一些其他的项目打好了心理基础，以前总是是会担心要怎么开始。
工作方面 整个一年其实没有什么很实质的进步，可能是由于公司业务方向发生了明显的改变，和我自己的想做的方向相去甚远，手上有一些做了很久的工作至今没有看到要上线的迹象，也让我非常沮丧。
在这期间我也向我的leader多次表达过想要转岗到后端开发，不过是实际情况来看，目前我所在的组离不开我（其实就我一个人），转岗变成了一个不可能的事情。
另外我也注意到身边一些离职的同事都去了一些不错的公司，实则让我非常羡慕。
2020年可以说是我职业生涯中最艰难的一年，其中有一个项目可能是由于需求不明确，加上我能力/理论不足，导致我做的非常地混沌，一共做了接近半年，对我而言简直是死亡行军，那段时间自身压力很大，虽然这个项目接近尾声，但我复盘之后得到的教训是：
对不熟悉的领域，应该尽快捡起预备知识。如果鲜有人问津，你甚至得读一些相关的论文。 不要使用自己刚入门的语言/技术写生产代码，Choose boring technology。 及时反馈进度，报告自己遇到的问题，以快速迭代。 每天手上不应该只做一件工作，有多份任务的情况下，可以适当切换，转换一下心情。 那段时间最能安抚我的可能就是下班之后可以做自己喜欢的事情了。不过这件事情也让我认识到了自己的局限性，还是需要深耕一下自己的基础，拓展知识面。</description></item><item><title>Perfect hashing for fixed-size string set</title><link>https://leiless.me/string-hash/</link><pubDate>Thu, 05 Apr 2018 00:00:00 +0000</pubDate><guid>https://leiless.me/string-hash/</guid><description>As aforementioned, we&amp;rsquo;ve dicussed perfect hashing for integers.
It turns out that the concept can be generalized for string hashing.
Leading out a simple question: How you do check if a string inside a small set?
Let&amp;rsquo;s concrete the question, consider we&amp;rsquo;re about to writing a C lexer.
The first step is to parse each token, we need to issue an error if any token mismatch the finite-state machine.
For example, like a variable name categorized into reserved keywords.</description></item><item><title>Compile shadowsocks-libev statically</title><link>https://leiless.me/compile-ss-libev/</link><pubDate>Mon, 31 Jul 2017 00:00:00 +0000</pubDate><guid>https://leiless.me/compile-ss-libev/</guid><description>(Update 2021-01-01: this article has been revised to adopt latest ss-libev)
Previously I&amp;rsquo;ve discussed how to compile and run an user-mode Linux.
In this post, I&amp;rsquo;ll talk about how to compile a statically-linked shadowsocks-libev.
 Preparation Before we do anything, we need to install basic build packages.
Following are common package group you may use:
CentOS/Fedora: sudo yum groupinstall &amp;quot;Development Tools&amp;quot;
Debian/Ubuntu: sudo apt-get install build-essential
Arch Linux/Manjaro: sudo pacman -Sy base-devel</description></item><item><title>Use BBR TCP congestion control in OpenVZ</title><link>https://leiless.me/openvz-bbr/</link><pubDate>Tue, 25 Jul 2017 00:00:00 +0000</pubDate><guid>https://leiless.me/openvz-bbr/</guid><description>Assumption I&amp;rsquo;m assuming you&amp;rsquo;re using Linux distribution, and in a KVM environment(Which the loop device will be used).
Any step need root privilege, the sudo prefix will be added.
Making an Alpine Linux image First thing you should do is to choose a Linux distribution, among all known Linux distros, Alpine Linux is a good choice, it&amp;rsquo;s small and simple, so it gonna be our choice.
The core idea is to making an UML(User-mode Linux) image.</description></item><item><title>Endianness Matters</title><link>https://leiless.me/endianness-matters/</link><pubDate>Sat, 22 Jul 2017 00:00:00 +0000</pubDate><guid>https://leiless.me/endianness-matters/</guid><description>Things happen rarely if you&amp;rsquo;re in an application-level development and want to write endian-independant code.
Occasionally, you need to consider about endian in low-level view, but that might confusing and even erroneous if you don&amp;rsquo;t fully understand it.
 Before we begin to talking about why endian matters, a brief introduction of endian is needed.
Endian for short, is the physical organization schema of the sequential stream. Note that it&amp;rsquo;s not exclusive only to computer science field.</description></item><item><title>Lowest Bit Set</title><link>https://leiless.me/lowest-bit-set/</link><pubDate>Sat, 01 Jul 2017 00:00:00 +0000</pubDate><guid>https://leiless.me/lowest-bit-set/</guid><description>How do you solve the question &amp;ldquo;Determine position of lowest bit set&amp;rdquo;?
I&amp;rsquo;m not excepting you to solve it by now, but think about it.
The intuitive way to solve it may like Position of lowest bit set:
1 2 3 4 5 6 7 8 9 10 11 12 13 unsigned int lowest_bit_set_naive(unsigned int x) { // x=0 is not properly handled by while-loop if (x == 0) return 0; unsigned int result = 0; while ((x &amp;amp; 1) == 0) { x &amp;gt;&amp;gt;= 1; result++; } return result; } Yes, it solved the question nicely, I don&amp;rsquo;t want be captious, 0 and 1 have the same value returned :-(</description></item></channel></rss>