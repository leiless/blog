<!doctype html><html>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge"><title>Perfect hashing for fixed-size string set - 一个程序员的辩白</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta itemprop=name content="Perfect hashing for fixed-size string set">
<meta itemprop=description content="As aforementioned, we&rsquo;ve dicussed perfect hashing for integers.
It turns out that the concept can be generalized for string hashing.
Leading out a simple question: How you do check if a string inside a small set?
Let&rsquo;s concrete the question, consider we&rsquo;re about to writing a C lexer.
The first step is to parse each token, we need to issue an error if any token mismatch the finite-state machine.
For example, like a variable name categorized into reserved keywords."><meta itemprop=datePublished content="2018-04-05T00:00:00+00:00">
<meta itemprop=dateModified content="2018-04-05T00:00:00+00:00">
<meta itemprop=wordCount content="2164">
<meta itemprop=keywords content><meta property="og:title" content="Perfect hashing for fixed-size string set">
<meta property="og:description" content="As aforementioned, we&rsquo;ve dicussed perfect hashing for integers.
It turns out that the concept can be generalized for string hashing.
Leading out a simple question: How you do check if a string inside a small set?
Let&rsquo;s concrete the question, consider we&rsquo;re about to writing a C lexer.
The first step is to parse each token, we need to issue an error if any token mismatch the finite-state machine.
For example, like a variable name categorized into reserved keywords.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://leiless.me/posts/string-hash/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2018-04-05T00:00:00+00:00">
<meta property="article:modified_time" content="2018-04-05T00:00:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Perfect hashing for fixed-size string set">
<meta name=twitter:description content="As aforementioned, we&rsquo;ve dicussed perfect hashing for integers.
It turns out that the concept can be generalized for string hashing.
Leading out a simple question: How you do check if a string inside a small set?
Let&rsquo;s concrete the question, consider we&rsquo;re about to writing a C lexer.
The first step is to parse each token, we need to issue an error if any token mismatch the finite-state machine.
For example, like a variable name categorized into reserved keywords.">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700" rel=stylesheet type=text/css>
<link rel=stylesheet type=text/css media=screen href=https://leiless.me/css/normalize.css>
<link rel=stylesheet type=text/css media=screen href=https://leiless.me/css/main.css>
<link id=dark-scheme rel=stylesheet type=text/css href=https://leiless.me/css/dark.css>
<script src=https://leiless.me/js/feather.min.js></script>
<script src=https://leiless.me/js/main.js></script>
</head>
<body>
<div class="container wrapper">
<div class=header>
<div class=avatar>
<a href=https://leiless.me/>
<img src=../../avatar.jpg alt=一个程序员的辩白>
</a>
</div>
<h1 class=site-title><a href=https://leiless.me/>一个程序员的辩白</a></h1>
<div class=site-description><nav class="nav social">
<ul class=flat><li><a href=https://github.com/leiless title=GitHub><i data-feather=github></i></a></li><li><a href=https://twitter.com/funky_fishbone title=Twitter><i data-feather=twitter></i></a></li><li><a href=/index.xml title=RSS><i data-feather=rss></i></a></li><li><a href=# class=scheme-toggle id=scheme-toggle></a></li></ul>
</nav>
</div>
<nav class=nav>
<ul class=flat>
</ul>
</nav>
</div>
<div class=post>
<div class=post-header>
<div class=meta>
<div class=date>
<span class=day>05</span>
<span class=rest>Apr 2018</span>
</div>
</div>
<div class=matter>
<h1 class=title>Perfect hashing for fixed-size string set</h1>
</div>
</div>
<div class=markdown>
<p>As <a href=../lowest-bit-set/>aforementioned</a>, we&rsquo;ve dicussed perfect hashing for integers.</p>
<p>It turns out that the concept can be generalized for string hashing.</p>
<p>Leading out a simple question: How you do check if a string inside a small set?</p>
<p>Let&rsquo;s concrete the question, consider we&rsquo;re about to writing a C lexer.</p>
<p>The first step is to parse each token, we need to issue an error if any token mismatch the finite-state machine.</p>
<p>For example, like a variable name categorized into reserved keywords.</p>
<p> </p>
<p>Considering we want to write a C89-compatible tokenizer, we thus have following 32 keywords.</p>
<p>|auto|break|case|char|const|continue|default|do|
|double|else|enum|extern|float|for|goto|if|
|int|long|register|return|short|signed|sizeof|static|
|struct|switch|typedef|union|unsigned|void|volatile|while|</p>
<p>We can easily write out first naive draft.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#00f>static</span> <span style=color:#00f>const</span> <span style=color:#2b91af>char</span> *c89kws[] = {
	<span style=color:#a31515>&#34;auto&#34;</span>, <span style=color:#a31515>&#34;break&#34;</span>, <span style=color:#a31515>&#34;case&#34;</span>, <span style=color:#a31515>&#34;char&#34;</span>, <span style=color:#a31515>&#34;const&#34;</span>, <span style=color:#a31515>&#34;continue&#34;</span>, <span style=color:#a31515>&#34;default&#34;</span>, <span style=color:#a31515>&#34;do&#34;</span>,
	<span style=color:#a31515>&#34;double&#34;</span>, <span style=color:#a31515>&#34;else&#34;</span>, <span style=color:#a31515>&#34;enum&#34;</span>, <span style=color:#a31515>&#34;extern&#34;</span>, <span style=color:#a31515>&#34;float&#34;</span>, <span style=color:#a31515>&#34;for&#34;</span>, <span style=color:#a31515>&#34;goto&#34;</span>, <span style=color:#a31515>&#34;if&#34;</span>,
	<span style=color:#a31515>&#34;int&#34;</span>, <span style=color:#a31515>&#34;long&#34;</span>, <span style=color:#a31515>&#34;register&#34;</span>, <span style=color:#a31515>&#34;return&#34;</span>, <span style=color:#a31515>&#34;short&#34;</span>, <span style=color:#a31515>&#34;signed&#34;</span>, <span style=color:#a31515>&#34;sizeof&#34;</span>, <span style=color:#a31515>&#34;static&#34;</span>,
	<span style=color:#a31515>&#34;struct&#34;</span>, <span style=color:#a31515>&#34;switch&#34;</span>, <span style=color:#a31515>&#34;typedef&#34;</span>, <span style=color:#a31515>&#34;union&#34;</span>, <span style=color:#a31515>&#34;unsigned&#34;</span>, <span style=color:#a31515>&#34;void&#34;</span>, <span style=color:#a31515>&#34;volatile&#34;</span>, <span style=color:#a31515>&#34;while&#34;</span>,
};

<span style=color:#2b91af>int</span> is_rsrv_c89kw(<span style=color:#00f>const</span> <span style=color:#2b91af>char</span> *tok)
{
	assert(tok != NULL);
	size_t i, sz = <span style=color:#00f>sizeof</span>(c89kws) / <span style=color:#00f>sizeof</span>(<span style=color:#2b91af>char</span> *);
	<span style=color:#00f>for</span> (i = 0; i &lt; sz; i++)
		<span style=color:#00f>if</span> (!strcmp(tok, c89kws[i]))
			<span style=color:#00f>return</span> 1;
	<span style=color:#00f>return</span> 0;
}
</code></pre></div><p>Complexity of above solution is <code>O(m * n)</code>, which <code>m</code> is average length of the keyword list, <code>n</code> is the size of the keyword list.</p>
<p> </p>
<p>Yet some guys may happen to optimize this by binary search, which yields the second draft.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#2b91af>int</span> is_rsrv_c89kw2(<span style=color:#00f>const</span> <span style=color:#2b91af>char</span> *tok)
{
	assert(tok != NULL);

	<span style=color:#2b91af>int</span> l = 0, r = <span style=color:#00f>sizeof</span>(c89kws) / <span style=color:#00f>sizeof</span>(<span style=color:#2b91af>char</span> *) - 1;
	<span style=color:#2b91af>int</span> m, cmp;

	<span style=color:#00f>while</span> (l &lt;= r) {
		m = l + ((r - l) &gt;&gt; 1);
		cmp = strcmp(tok, c89kws[m]);
		<span style=color:#00f>if</span> (cmp == 0)
			<span style=color:#00f>return</span> 1;
		cmp &gt; 0 ? (l = m + 1) : (r = m - 1);
	}

	<span style=color:#00f>return</span> 0;
}
</code></pre></div><p>This should be reasonable for real-life implementation, time complexity down to <code>O(m * log2(n)</code>.</p>
<p> </p>
<p>Now we pursue a third solution, perfect hashing, first we need to probe an array that makes each elements in the list having an unique hash value(reduce the string to hash-value), the we utilize the integer perfect hashing for string matching.</p>
<p>By reducing string to integer value, we have lots of choices, the cheapest way is to hash.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:green>/*
</span><span style=color:green> * This is a bad string-hash function, yet useful when used in fixed-set
</span><span style=color:green> */</span>
<span style=color:#00f>#define LOSELOSE2(s) ({         \
</span><span style=color:#00f>    const char *p = s;          \
</span><span style=color:#00f>    unsigned int i, h = 0;      \
</span><span style=color:#00f>    for (i = 0; p[i]; i++)      \
</span><span style=color:#00f>        h += p[i] | (i + 1);    \
</span><span style=color:#00f>    h;                          \
</span><span style=color:#00f>})
</span></code></pre></div><p>Above is one of the possible hash function, when apply to the give list, it yields the result(not yet sorted, any two of them not equal).</p>
<blockquote>
<p>446, 528, 414, 422, 557, 884, 754, 212, 645, 427, 439, 672, 542, 329, 444, 207,</p>
<p>334, 434, 892, 683, 567, 638, 659, 660, 686, 670, 763, 556, 875, 437, 890, 541,</p>
</blockquote>
<p>P.S. if we replace <code>(i + 1)</code> with <code>0</code>, the<code> LOSELOSE2()</code> become <a href=http://www.cse.yorku.ca/~oz/hash.html>classic K&R lose-lose</a>.</p>
<p> </p>
<p>Now we need to probe an unique magic number which reduce those 32 numbers into range <em>[0, 32)</em>, and also any two of them cannot overlap.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#00f>static</span> <span style=color:#00f>const</span> <span style=color:#2b91af>char</span> *c89kws[] = {
    <span style=color:#a31515>&#34;auto&#34;</span>, <span style=color:#a31515>&#34;break&#34;</span>, <span style=color:#a31515>&#34;case&#34;</span>, <span style=color:#a31515>&#34;char&#34;</span>, <span style=color:#a31515>&#34;const&#34;</span>, <span style=color:#a31515>&#34;continue&#34;</span>, <span style=color:#a31515>&#34;default&#34;</span>, <span style=color:#a31515>&#34;do&#34;</span>,
    <span style=color:#a31515>&#34;double&#34;</span>, <span style=color:#a31515>&#34;else&#34;</span>, <span style=color:#a31515>&#34;enum&#34;</span>, <span style=color:#a31515>&#34;extern&#34;</span>, <span style=color:#a31515>&#34;float&#34;</span>, <span style=color:#a31515>&#34;for&#34;</span>, <span style=color:#a31515>&#34;goto&#34;</span>, <span style=color:#a31515>&#34;if&#34;</span>,
    <span style=color:#a31515>&#34;int&#34;</span>, <span style=color:#a31515>&#34;long&#34;</span>, <span style=color:#a31515>&#34;register&#34;</span>, <span style=color:#a31515>&#34;return&#34;</span>, <span style=color:#a31515>&#34;short&#34;</span>, <span style=color:#a31515>&#34;signed&#34;</span>, <span style=color:#a31515>&#34;sizeof&#34;</span>, <span style=color:#a31515>&#34;static&#34;</span>,
    <span style=color:#a31515>&#34;struct&#34;</span>, <span style=color:#a31515>&#34;switch&#34;</span>, <span style=color:#a31515>&#34;typedef&#34;</span>, <span style=color:#a31515>&#34;union&#34;</span>, <span style=color:#a31515>&#34;unsigned&#34;</span>, <span style=color:#a31515>&#34;void&#34;</span>, <span style=color:#a31515>&#34;volatile&#34;</span>, <span style=color:#a31515>&#34;while&#34;</span>,
};

<span style=color:#00f>#define COT 32
</span><span style=color:#00f>#define SLOT 32
</span><span style=color:#00f></span>
<span style=color:green>/* See previously article for details */</span>
<span style=color:#00f>#define TYPE unsigned int
</span><span style=color:#00f>#define SHIFT 27
</span><span style=color:#00f>#define HASH(x) (((TYPE) (x)) &gt;&gt; SHIFT)
</span><span style=color:#00f></span>
<span style=color:#00f>static</span> <span style=color:#2b91af>unsigned</span> <span style=color:#2b91af>int</span> kwh[COT];

<span style=color:#2b91af>void</span> probing(<span style=color:#2b91af>void</span>)
{
    TYPE i, j;
    <span style=color:#2b91af>char</span> buff[SLOT];

    <span style=color:#00f>for</span> (i = 0x1; i != 0; i++) {
        memset(buff, -1, <span style=color:#00f>sizeof</span>(buff));

        <span style=color:#00f>for</span> (j = 0; j &lt; COT; j++) {
            <span style=color:green>/* each bit should mapped into unique slot */</span>
            <span style=color:#00f>if</span> (++buff[HASH(kwh[j] * i)] != 0)
                <span style=color:#00f>break</span>;
        }

        <span style=color:#00f>if</span> (j == COT)
            <span style=color:#00f>break</span>;
    }

    <span style=color:#00f>if</span> (i == 0) {
        fprintf(stderr, <span style=color:#a31515>&#34;probe failed</span><span style=color:#a31515>\n</span><span style=color:#a31515>&#34;</span>);
        <span style=color:#00f>return</span>;
    }

    printf(<span style=color:#a31515>&#34;%#0*x:</span><span style=color:#a31515>\n</span><span style=color:#a31515>&#34;</span>, (<span style=color:#2b91af>int</span>) ((<span style=color:#00f>sizeof</span>(i) + 1) &lt;&lt; 1), i);

    <span style=color:#00f>for</span> (j = 0; j &lt; COT; j++) {
        <span style=color:green>/* mapping from bitmap into index */</span>
        buff[HASH(kwh[j] * i)] = j;
    }

    <span style=color:#00f>for</span> (j = 0; j &lt; SLOT; j++) {
        printf(<span style=color:#a31515>&#34;%2d,&#34;</span>, buff[j]);
        putchar(j % 8 != 7 ? <span style=color:#a31515>&#39; &#39;</span> : <span style=color:#a31515>&#39;\n&#39;</span>);
    }
}

<span style=color:#00f>#define LOSELOSE2(s) ({         \
</span><span style=color:#00f>    const char *p = s;          \
</span><span style=color:#00f>    unsigned int i, h = 0;      \
</span><span style=color:#00f>    for (i = 0; p[i]; i++)      \
</span><span style=color:#00f>        h += p[i] | (i + 1);    \
</span><span style=color:#00f>    h;                          \
</span><span style=color:#00f>})
</span><span style=color:#00f></span>
<span style=color:#2b91af>int</span> main(<span style=color:#2b91af>void</span>)
{
    size_t i, sz = <span style=color:#00f>sizeof</span>(c89kws) / <span style=color:#00f>sizeof</span>(<span style=color:#2b91af>char</span> *);

    <span style=color:#00f>for</span> (i = 0; i &lt; sz; i++)
        kwh[i] = LOSELOSE2(c89kws[i]);

    probing();

    <span style=color:#00f>return</span> 0;
}
</code></pre></div><p>Unfortunately, if you run above program, it will print <code>probe failed</code> message.</p>
<p>If you take a closer look at those string-hash values(I sorted them for convenience).</p>
<blockquote>
<p>207, 212, 329, 334, 414, 422, 427, 434, 437, 439, 444, 446, 528, 541, 542, 556,</p>
<p>557, 567, 638, 645, 659, 660, 670, 672, 683, 686, 754, 763, 875, 884, 890, 892,</p>
</blockquote>
<p>You&rsquo;ll find that they&rsquo;re too close to each other(that&rsquo;s why I used a variant of lose-lose), which of course proved <code>loselose</code> is an extremely poor hash function.</p>
<p>There are two obvious solutions:</p>
<ul>
<li>
<p>Pursue an uniformly distributed(universal) hash function</p>
</li>
<li>
<p>Expand the slots, which allow empty(unused) slot.</p>
</li>
</ul>
<p>Difficulty for the first one is that it&rsquo;s not easy to find such hash function which strike a balance between simplicity and speed.</p>
<p>The drawback for the second one is that it may consume extra space to store unused slots, yet, it may overstated, consider I want to add two extra keywords <code>inline</code> and <code>restrict</code> to the keyword list, which the unused slots can now be used without reinventing a new hash function.</p>
<p> </p>
<p>So, if I double the slots number(half of them will be unused thus), and of course we also need to change the hash a little bit:</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#00f>#define SLOT 64
</span><span style=color:#00f>#define SHIFT 26    </span><span style=color:green>/* 32 - log2(64) = 32 - 6 = 26 */</span><span style=color:#00f>
</span></code></pre></div><p>You would see the following output:</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>0x02da187e:
-1, 31, 12, -1, -1, -1, 21, -1,
-1, -1, -1,  8, 27,  4, -1, -1,
-1, -1, -1, 15, 20, 22, 23,  7,
-1,  6, -1, -1, -1, 25, -1, 11,
26, -1, -1, -1, -1, -1, 19,  2,
-1, 24, 13, -1,  3, -1, 16, 28,
 9, -1, -1, -1, -1, 17,  5, 29,
 1, 10, 30, 18, 14,  0, -1, -1,
</code></pre></div><p>Of which, -1 indicate unused slots. and other indices should map to corresponding string in the <code>c89kws</code> array.</p>
<p> </p>
<p>Hence we have a third draft, hopefully it&rsquo;s the final one.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#00f>static</span> <span style=color:#00f>const</span> <span style=color:#2b91af>char</span> *c89kwmap[] = {
    NULL, <span style=color:#a31515>&#34;while&#34;</span>, <span style=color:#a31515>&#34;float&#34;</span>, NULL, NULL, NULL, <span style=color:#a31515>&#34;signed&#34;</span>, NULL,
    NULL, NULL, NULL, <span style=color:#a31515>&#34;double&#34;</span>, <span style=color:#a31515>&#34;union&#34;</span>, <span style=color:#a31515>&#34;const&#34;</span>, NULL, NULL,
    NULL, NULL, NULL, <span style=color:#a31515>&#34;if&#34;</span>, <span style=color:#a31515>&#34;short&#34;</span>, <span style=color:#a31515>&#34;sizeof&#34;</span>, <span style=color:#a31515>&#34;static&#34;</span>, <span style=color:#a31515>&#34;do&#34;</span>,
    NULL, <span style=color:#a31515>&#34;default&#34;</span>, NULL, NULL, NULL, <span style=color:#a31515>&#34;switch&#34;</span>, NULL, <span style=color:#a31515>&#34;extern&#34;</span>,
    <span style=color:#a31515>&#34;typedef&#34;</span>, NULL, NULL, NULL, NULL, NULL, <span style=color:#a31515>&#34;return&#34;</span>, <span style=color:#a31515>&#34;case&#34;</span>,
    NULL, <span style=color:#a31515>&#34;struct&#34;</span>, <span style=color:#a31515>&#34;for&#34;</span>, NULL, <span style=color:#a31515>&#34;char&#34;</span>, NULL, <span style=color:#a31515>&#34;int&#34;</span>, <span style=color:#a31515>&#34;unsigned&#34;</span>,
    <span style=color:#a31515>&#34;else&#34;</span>, NULL, NULL, NULL, NULL, <span style=color:#a31515>&#34;long&#34;</span>, <span style=color:#a31515>&#34;continue&#34;</span>, <span style=color:#a31515>&#34;void&#34;</span>,
    <span style=color:#a31515>&#34;break&#34;</span>, <span style=color:#a31515>&#34;enum&#34;</span>, <span style=color:#a31515>&#34;volatile&#34;</span>, <span style=color:#a31515>&#34;register&#34;</span>, <span style=color:#a31515>&#34;goto&#34;</span>, <span style=color:#a31515>&#34;auto&#34;</span>, NULL, NULL,
};

<span style=color:#00f>#define LOSELOSE2(s) ({         \
</span><span style=color:#00f>    const char *p = s;          \
</span><span style=color:#00f>    unsigned int i, h = 0;      \
</span><span style=color:#00f>    for (i = 0; p[i]; i++)      \
</span><span style=color:#00f>        h += p[i] | (i + 1);    \
</span><span style=color:#00f>    h;                          \
</span><span style=color:#00f>})
</span><span style=color:#00f></span>
<span style=color:#00f>#define MAGIC    0x02da187eu
</span><span style=color:#00f>#define SHIFT    26u
</span><span style=color:#00f>#define QHASH(x) (((unsigned int) (x * MAGIC)) &gt;&gt; SHIFT)
</span><span style=color:#00f></span>
<span style=color:#2b91af>int</span> is_rsrv_c89kw3(<span style=color:#00f>const</span> <span style=color:#2b91af>char</span> *tok)
{
    assert(tok != NULL);
    <span style=color:#00f>const</span> <span style=color:#2b91af>char</span> *p = c89kwmap[QHASH(LOSELOSE2(tok))];
    <span style=color:#00f>return</span> p &amp;&amp; !strcmp(p, tok);
}
</code></pre></div><p>As the code revealed, it hashed twice, and yield one string comparison. Which is <code>O(n)</code> time complexity for any given string.</p>
<p>Even better than the binary search version.</p>
<p> </p>
<p><strong>Updated Apr 29, 2018</strong></p>
<p>Yet here comes a fourth draft, which even faster than <code>is_rsrv_c89kw3()</code>.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#00f>static</span> <span style=color:#00f>const</span> <span style=color:#2b91af>char</span> *c89kwmap2[] = {
    <span style=color:#a31515>&#34;default&#34;</span>, NULL, <span style=color:#a31515>&#34;short&#34;</span>, NULL, <span style=color:#a31515>&#34;goto&#34;</span>, <span style=color:#a31515>&#34;continue&#34;</span>, <span style=color:#a31515>&#34;auto&#34;</span>, NULL,
    NULL, <span style=color:#a31515>&#34;typedef&#34;</span>, <span style=color:#a31515>&#34;signed&#34;</span>, <span style=color:#a31515>&#34;volatile&#34;</span>, NULL, <span style=color:#a31515>&#34;register&#34;</span>, NULL, <span style=color:#a31515>&#34;for&#34;</span>,
    NULL, <span style=color:#a31515>&#34;double&#34;</span>, NULL, <span style=color:#a31515>&#34;if&#34;</span>, <span style=color:#a31515>&#34;int&#34;</span>, NULL, NULL, NULL,
    <span style=color:#a31515>&#34;do&#34;</span>, NULL, <span style=color:#a31515>&#34;break&#34;</span>, NULL, NULL, NULL, NULL, <span style=color:#a31515>&#34;sizeof&#34;</span>,
    <span style=color:#a31515>&#34;static&#34;</span>, NULL, NULL, NULL, NULL, NULL, <span style=color:#a31515>&#34;case&#34;</span>, <span style=color:#a31515>&#34;while&#34;</span>,
    <span style=color:#a31515>&#34;float&#34;</span>, NULL, NULL, <span style=color:#a31515>&#34;switch&#34;</span>, NULL, <span style=color:#a31515>&#34;extern&#34;</span>, <span style=color:#a31515>&#34;char&#34;</span>, NULL,
    NULL, NULL, NULL, <span style=color:#a31515>&#34;else&#34;</span>, NULL, NULL, <span style=color:#a31515>&#34;union&#34;</span>, <span style=color:#a31515>&#34;const&#34;</span>,
    <span style=color:#a31515>&#34;return&#34;</span>, NULL, <span style=color:#a31515>&#34;long&#34;</span>, <span style=color:#a31515>&#34;struct&#34;</span>, <span style=color:#a31515>&#34;unsigned&#34;</span>, <span style=color:#a31515>&#34;void&#34;</span>, NULL, <span style=color:#a31515>&#34;enum&#34;</span>,
};

<span style=color:#00f>#define LOSELOSE2(s) ({         \
</span><span style=color:#00f>    const char *p = s;          \
</span><span style=color:#00f>    unsigned int i, h = 0;      \
</span><span style=color:#00f>    for (i = 0; p[i]; i++)      \
</span><span style=color:#00f>        h += p[i] | (i + 1);    \
</span><span style=color:#00f>    h;                          \
</span><span style=color:#00f>})
</span><span style=color:#00f></span>
<span style=color:green>/*
</span><span style=color:green> * Hint:
</span><span style=color:green> * We may go even further by finding an uint8_t, and shift 8 - 6 = 2 bits.
</span><span style=color:green> */</span>
<span style=color:#00f>#define MAGIC     0x0414u
</span><span style=color:#00f>#define SHIFT     10u
</span><span style=color:#00f>#define QHASH2(x) (((unsigned short) (x * MAGIC)) &gt;&gt; SHIFT)
</span><span style=color:#00f></span>
<span style=color:#2b91af>int</span> is_rsrv_c89kw4(<span style=color:#00f>const</span> <span style=color:#2b91af>char</span> *tok)
{
    assert(tok != NULL);
    <span style=color:#00f>const</span> <span style=color:#2b91af>char</span> *p = c89kwmap2[QHASH2(LOSELOSE2(tok))];
    <span style=color:green>/* False-positive comparison */</span>
    <span style=color:#00f>return</span> p &amp;&amp; !strcmp(p, tok);
}
</code></pre></div><p>Feel free to add more keywords, and then recalculate the string-map and magic number.</p>
<p> </p>
<p>If your hash function is universal enough, you may happen to find a magic number without expanding the slots, and even reduce the hash value into an <em>unsigned char</em>, i.e. <code>uint8_t</code>, so the second hash consumes nearly nothing.</p>
<p>The <code>is_rsrv_c89kw4()</code> done nearly perfect, the first string-hash is simple enough, and the second hash reduced first one into an <em>unsigned short</em>, i.e. <code>uint16_t</code>.</p>
<p>You may take further expansion over slots, which yield even smaller magic number(with penalty of extra space).</p>
<p> </p>
<p>If you using <a href=https://www.gnu.org/software/gperf/>GNU gperf</a> to generate hash function, put above keywords as input, you&rsquo;ll find similar pattern.</p>
<p>FYI, I&rsquo;ve put the machine-generated result here. Happy hacking!</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#00f>#define TOTAL_KEYWORDS 32
</span><span style=color:#00f>#define MIN_WORD_LENGTH 2
</span><span style=color:#00f>#define MAX_WORD_LENGTH 8
</span><span style=color:#00f>#define MIN_HASH_VALUE 3
</span><span style=color:#00f>#define MAX_HASH_VALUE 44
</span><span style=color:#00f></span><span style=color:green>/* maximum key range = 42, duplicates = 0 */</span>

<span style=color:#00f>inline</span> <span style=color:#00f>static</span> <span style=color:#2b91af>unsigned</span> <span style=color:#2b91af>int</span> hash(<span style=color:#00f>register</span> <span style=color:#00f>const</span> <span style=color:#2b91af>char</span> *str, <span style=color:#00f>register</span> size_t len)
{
  <span style=color:#00f>static</span> <span style=color:#2b91af>unsigned</span> <span style=color:#2b91af>char</span> asso_values[] = {
      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
      45, 45, 45, 45, 45, 45, 45, 30, 10, 10,
      25, 20,  0, 10, 45,  5, 45, 45, 25, 45,
      10, 10,  5, 45,  0,  5,  0,  0,  0, 20,
      45, 45, 25, 45, 45, 45, 45, 45, 45, 45,
      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
      45, 45, 45, 45, 45, 45, 45, 45, 45, 45,
      45, 45, 45, 45, 45, 45
    };
  <span style=color:#00f>register</span> <span style=color:#2b91af>unsigned</span> <span style=color:#2b91af>int</span> hval = len;

  <span style=color:#00f>switch</span> (hval) {
      <span style=color:#00f>default</span>:
        hval += asso_values[(<span style=color:#2b91af>unsigned</span> <span style=color:#2b91af>char</span>)str[2]];
      <span style=color:green>/*FALLTHROUGH*/</span>
      <span style=color:#00f>case</span> 2:
      <span style=color:#00f>case</span> 1:
        hval += asso_values[(<span style=color:#2b91af>unsigned</span> <span style=color:#2b91af>char</span>)str[0]];
        <span style=color:#00f>break</span>;
    }
  <span style=color:#00f>return</span> hval;
}

<span style=color:#00f>const</span> <span style=color:#2b91af>char</span> *in_word_set(<span style=color:#00f>register</span> <span style=color:#00f>const</span> <span style=color:#2b91af>char</span> *str, <span style=color:#00f>register</span> size_t len)
{
  <span style=color:#00f>static</span> <span style=color:#00f>const</span> <span style=color:#2b91af>char</span> * wordlist[] = {
      <span style=color:#a31515>&#34;&#34;</span>, <span style=color:#a31515>&#34;&#34;</span>, <span style=color:#a31515>&#34;&#34;</span>, <span style=color:#a31515>&#34;for&#34;</span>, <span style=color:#a31515>&#34;&#34;</span>, <span style=color:#a31515>&#34;&#34;</span>, <span style=color:#a31515>&#34;return&#34;</span>, <span style=color:#a31515>&#34;if&#34;</span>, <span style=color:#a31515>&#34;int&#34;</span>, <span style=color:#a31515>&#34;void&#34;</span>,
      <span style=color:#a31515>&#34;union&#34;</span>, <span style=color:#a31515>&#34;struct&#34;</span>, <span style=color:#a31515>&#34;typedef&#34;</span>, <span style=color:#a31515>&#34;unsigned&#34;</span>, <span style=color:#a31515>&#34;goto&#34;</span>, <span style=color:#a31515>&#34;float&#34;</span>,
      <span style=color:#a31515>&#34;switch&#34;</span>, <span style=color:#a31515>&#34;&#34;</span>, <span style=color:#a31515>&#34;register&#34;</span>, <span style=color:#a31515>&#34;case&#34;</span>, <span style=color:#a31515>&#34;short&#34;</span>, <span style=color:#a31515>&#34;signed&#34;</span>, <span style=color:#a31515>&#34;&#34;</span>, <span style=color:#a31515>&#34;&#34;</span>,
      <span style=color:#a31515>&#34;enum&#34;</span>, <span style=color:#a31515>&#34;const&#34;</span>, <span style=color:#a31515>&#34;extern&#34;</span>, <span style=color:#a31515>&#34;do&#34;</span>, <span style=color:#a31515>&#34;continue&#34;</span>, <span style=color:#a31515>&#34;else&#34;</span>, <span style=color:#a31515>&#34;while&#34;</span>,
      <span style=color:#a31515>&#34;double&#34;</span>, <span style=color:#a31515>&#34;default&#34;</span>, <span style=color:#a31515>&#34;volatile&#34;</span>, <span style=color:#a31515>&#34;auto&#34;</span>, <span style=color:#a31515>&#34;break&#34;</span>, <span style=color:#a31515>&#34;sizeof&#34;</span>,
      <span style=color:#a31515>&#34;&#34;</span>, <span style=color:#a31515>&#34;&#34;</span>, <span style=color:#a31515>&#34;long&#34;</span>, <span style=color:#a31515>&#34;&#34;</span>, <span style=color:#a31515>&#34;static&#34;</span>, <span style=color:#a31515>&#34;&#34;</span>, <span style=color:#a31515>&#34;&#34;</span>, <span style=color:#a31515>&#34;char&#34;</span>
    };

  <span style=color:#00f>if</span> (len &lt;= MAX_WORD_LENGTH &amp;&amp; len &gt;= MIN_WORD_LENGTH) {
      <span style=color:#00f>register</span> <span style=color:#2b91af>unsigned</span> <span style=color:#2b91af>int</span> key = hash (str, len);

      <span style=color:#00f>if</span> (key &lt;= MAX_HASH_VALUE) {
          <span style=color:#00f>register</span> <span style=color:#00f>const</span> <span style=color:#2b91af>char</span> *s = wordlist[key];

          <span style=color:#00f>if</span> (*str == *s &amp;&amp; !strcmp (str + 1, s + 1))
            <span style=color:#00f>return</span> s;
        }
    }
  <span style=color:#00f>return</span> 0;
}
</code></pre></div><p> </p>
<p><strong>Updated Jan 03, 2020</strong></p>
<p>One drawback of the perfect hashing is that after we got a magic array, the order of the array has been shuffled due to the two-way hashing.</p>
<p>If we want to bound the array with an extra value, we need to introduce an extra value array, with the same organization of the key array.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#00f>static</span> <span style=color:#00f>const</span> <span style=color:#2b91af>char</span> *c89kw_key[] = {
    <span style=color:#a31515>&#34;default&#34;</span>, NULL, <span style=color:#a31515>&#34;short&#34;</span>, NULL, <span style=color:#a31515>&#34;goto&#34;</span>, <span style=color:#a31515>&#34;continue&#34;</span>, <span style=color:#a31515>&#34;auto&#34;</span>, NULL,
    NULL, <span style=color:#a31515>&#34;typedef&#34;</span>, <span style=color:#a31515>&#34;signed&#34;</span>, <span style=color:#a31515>&#34;volatile&#34;</span>, NULL, <span style=color:#a31515>&#34;register&#34;</span>, NULL, <span style=color:#a31515>&#34;for&#34;</span>,
    NULL, <span style=color:#a31515>&#34;double&#34;</span>, NULL, <span style=color:#a31515>&#34;if&#34;</span>, <span style=color:#a31515>&#34;int&#34;</span>, NULL, NULL, NULL,
    <span style=color:#a31515>&#34;do&#34;</span>, NULL, <span style=color:#a31515>&#34;break&#34;</span>, NULL, NULL, NULL, NULL, <span style=color:#a31515>&#34;sizeof&#34;</span>,
    <span style=color:#a31515>&#34;static&#34;</span>, NULL, NULL, NULL, NULL, NULL, <span style=color:#a31515>&#34;case&#34;</span>, <span style=color:#a31515>&#34;while&#34;</span>,
    <span style=color:#a31515>&#34;float&#34;</span>, NULL, NULL, <span style=color:#a31515>&#34;switch&#34;</span>, NULL, <span style=color:#a31515>&#34;extern&#34;</span>, <span style=color:#a31515>&#34;char&#34;</span>, NULL,
    NULL, NULL, NULL, <span style=color:#a31515>&#34;else&#34;</span>, NULL, NULL, <span style=color:#a31515>&#34;union&#34;</span>, <span style=color:#a31515>&#34;const&#34;</span>,
    <span style=color:#a31515>&#34;return&#34;</span>, NULL, <span style=color:#a31515>&#34;long&#34;</span>, <span style=color:#a31515>&#34;struct&#34;</span>, <span style=color:#a31515>&#34;unsigned&#34;</span>, <span style=color:#a31515>&#34;void&#34;</span>, NULL, <span style=color:#a31515>&#34;enum&#34;</span>,
};

<span style=color:#00f>static</span> <span style=color:#00f>const</span> <span style=color:#2b91af>void</span> *c89kw_val[] = {
	<span style=color:#a31515>&#34;value for &#39;default&#39; key&#34;</span>, NULL, <span style=color:#a31515>&#34;value for &#39;short&#39;&#34;</span>, ...
}
</code></pre></div><p>Or we can also initialize the <code>c89kw_val</code> array on-the-fly:</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>(<span style=color:#2b91af>void</span>) memset(c89kw_val, 0, <span style=color:#00f>sizeof</span>(c89kw_val) / <span style=color:#00f>sizeof</span>(*c89kw_val));

c89kw_val[QHASH2(LOSELOSE2(<span style=color:#a31515>&#34;default&#34;</span>))] = <span style=color:green>/* value for &#39;default&#39; key */</span>;
<span style=color:green>/* ... */</span>
c89kw_val[QHASH2(LOSELOSE2(<span style=color:#a31515>&#34;enum&#34;</span>))] = <span style=color:green>/* ... */</span>;
</code></pre></div><p> </p>
<h3 id=references>References</h3>
<blockquote>
<p><a href=https://en.wikibooks.org/wiki/C_Programming/Language_Reference>C Programming/Language Reference#ANSI C (C89)/ISO C (C90)</a></p>
<p><a href=http://www.cse.yorku.ca/~oz/hash.html>Hash Functions</a></p>
<p><a href=https://aras-p.info/blog/2016/08/09/More-Hash-Function-Tests/>More Hash Function Tests</a></p>
</blockquote>
</div>
<div class=tags>
</div></div>
<script src=https://utteranc.es/client.js repo=leiless/blog issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script>
</div>
<div class="footer wrapper">
<nav class=nav>
<div>2021 Released under <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a> license | <a href=https://github.com/knadh/hugo-ink>Ink</a> theme on <a href=https://gohugo.io>Hugo</a></div>
</nav>
</div>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','G-RMJ7KLHXH8','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<script>feather.replace()</script>
</body>
</html>