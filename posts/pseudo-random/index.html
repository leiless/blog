<!doctype html><html>
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge"><title>Pseudorandom in chaos - 一个程序员的辩白</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta itemprop=name content="Pseudorandom in chaos">
<meta itemprop=description content="Randomized data is commonly used in fuzz testing, game engine, UUID, pipelines, etc.
Yet due to massive historically reasons, many C programmers tends to misuse the random functionalities.
 rand(3) and srand(3) Those two first appeared in Open Group Issue 1, it may a good starting point to explain why those two are commonly used among other pseudorandom functions.
As you examine the rand(3) implementation specification, you&rsquo;ll find some caveats:"><meta itemprop=datePublished content="2018-05-05T00:00:00+00:00">
<meta itemprop=dateModified content="2018-05-05T00:00:00+00:00">
<meta itemprop=wordCount content="1609">
<meta itemprop=keywords content><meta property="og:title" content="Pseudorandom in chaos">
<meta property="og:description" content="Randomized data is commonly used in fuzz testing, game engine, UUID, pipelines, etc.
Yet due to massive historically reasons, many C programmers tends to misuse the random functionalities.
 rand(3) and srand(3) Those two first appeared in Open Group Issue 1, it may a good starting point to explain why those two are commonly used among other pseudorandom functions.
As you examine the rand(3) implementation specification, you&rsquo;ll find some caveats:">
<meta property="og:type" content="article">
<meta property="og:url" content="https://leiless.me/posts/pseudo-random/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2018-05-05T00:00:00+00:00">
<meta property="article:modified_time" content="2018-05-05T00:00:00+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Pseudorandom in chaos">
<meta name=twitter:description content="Randomized data is commonly used in fuzz testing, game engine, UUID, pipelines, etc.
Yet due to massive historically reasons, many C programmers tends to misuse the random functionalities.
 rand(3) and srand(3) Those two first appeared in Open Group Issue 1, it may a good starting point to explain why those two are commonly used among other pseudorandom functions.
As you examine the rand(3) implementation specification, you&rsquo;ll find some caveats:">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700" rel=stylesheet type=text/css>
<link rel=stylesheet type=text/css media=screen href=https://leiless.me/css/normalize.css>
<link rel=stylesheet type=text/css media=screen href=https://leiless.me/css/main.css>
<link id=dark-scheme rel=stylesheet type=text/css href=https://leiless.me/css/dark.css>
<script src=https://leiless.me/js/feather.min.js></script>
<script src=https://leiless.me/js/main.js></script>
</head>
<body>
<div class="container wrapper">
<div class=header>
<div class=avatar>
<a href=https://leiless.me/>
<img src=../../avatar.jpg alt=一个程序员的辩白>
</a>
</div>
<h1 class=site-title><a href=https://leiless.me/>一个程序员的辩白</a></h1>
<div class=site-description><nav class="nav social">
<ul class=flat><li><a href=https://github.com/leiless title=GitHub><i data-feather=github></i></a></li><li><a href=https://twitter.com/fake_fishbone title=Twitter><i data-feather=twitter></i></a></li><li><a href=/index.xml title=RSS><i data-feather=rss></i></a></li><li><a href=# class=scheme-toggle id=scheme-toggle></a></li></ul>
</nav>
</div>
<nav class=nav>
<ul class=flat>
</ul>
</nav>
</div>
<div class=post>
<div class=post-header>
<div class=meta>
<div class=date>
<span class=day>05</span>
<span class=rest>May 2018</span>
</div>
</div>
<div class=matter>
<h1 class=title>Pseudorandom in chaos</h1>
</div>
</div>
<div class=markdown>
<p>Randomized data is commonly used in <a href=https://en.wikipedia.org/wiki/Fuzzing>fuzz testing</a>, game engine, <a href=https://en.wikipedia.org/wiki/Universally_unique_identifier>UUID</a>, pipelines, etc.</p>
<p>Yet due to massive historically reasons, many C programmers tends to misuse the random functionalities.</p>
<p> </p>
<h2 id=rand3-and-srand3>rand(3) and srand(3)</h2>
<p>Those two first appeared in <a href=http://pubs.opengroup.org/onlinepubs/9699919799/functions/rand.html>Open Group Issue 1</a>,
it may a good starting point to explain why those two are commonly used among other pseudorandom functions.</p>
<p>As you examine the <a href=http://pubs.opengroup.org/onlinepubs/9699919799/functions/rand.html>rand(3) implementation specification</a>, you&rsquo;ll find some caveats:</p>
<ul>
<li>Range:</li>
</ul>
<blockquote>
<p>The rand_r() function shall compute a sequence of pseudo-random integers in the range [0, {RAND_MAX}]. (The value of the {RAND_MAX} macro shall be at least 32767.)</p>
</blockquote>
<p>When dates back to early era, CPU is 16-bits addressable, people can only generate pseudorandom within 16-bits range, still a historically issue, thus we have to stay compatible.</p>
<p>Though standard specify the RAND_MAX at least sized 16-bits, since in nowadays, most mainstream CPUs are 32-bits, the backing OS standard library is fairy likely to define RAND_MAX as 32-bits maximum signed integer. Wish may satisfy general purpose.</p>
<p>You should definitely check the RAND_MAX macro manually if the range matters. Protability still issue if you want to write implementation-independent code.</p>
<ul>
<li>Period</li>
</ul>
<blockquote>
<p>The rand() function shall compute a sequence of pseudo-random integers in the range [0, {RAND_MAX}] [XSI] with a period of at least 2^32.</p>
</blockquote>
<p>This seems isn&rsquo;t an issue if your RAND_MAX is sized 32-bits or less, o.w. there may sequence loop.</p>
<p>Why period matters? Rationale quoted from <em>References</em></p>
<blockquote>
<p>Compare this with the Mersenne Twister algorithm, which is 2^19937-1. You typically want the period of a random number generator to exceed the amount of numbers expected to be generated, because that&rsquo;s the point where the sequence repeats.</p>
</blockquote>
<ul>
<li>Randomness quality</li>
</ul>
<p>Like select(2), rand(3) is another example of poor library implementation(at least once a while), old rand(3) implementation generate pseudorandom numbers which is predictable or not fully pseudorandomized.</p>
<p>(Nowaday rand(3) implementation have good quality over pseudorandomness, won&rsquo;t be a big issue though)</p>
<ul>
<li>Statistical distribution</li>
</ul>
<p>Still implementation-dependent, theoretically, distribution of general-purpose pseudorandom generator should conform <a href=https://en.wikipedia.org/wiki/Continuous_uniform_distribution>uniform distribution</a>. Yet the specification claim nothing upon the distribution.</p>
<p>FYI, quoted from <em>references</em>:</p>
<blockquote>
<p>Even when rand claims a uniform distribution, it may not be a terribly good distribution, which greatly affects any attempts to adjust the range.</p>
</blockquote>
<p>If the distribution is a critical factor, you may happen to write your own pseudorandom generator. In most cases, rand(3) satisfy your daily-use needs.</p>
<p> </p>
<p>A common misuse of rand(3) is use it without prior call srand(3), quoted from specification:</p>
<blockquote>
<p>The srand() function uses the argument as a seed for a new sequence of pseudo-random numbers to be returned by subsequent calls to rand(). If srand() is then called with the same seed value, the sequence of pseudo-random numbers shall be repeated. If rand() is called before any calls to srand() are made, the same sequence shall be generated as when srand() is first called with a seed value of 1.</p>
</blockquote>
<p>E.g. the srand() have initial seed 1 if no prior srand(3) call is made, in such case, you have no randomness at all.</p>
<p>So you inevitably need to seed the generator, yet another common misuse of srand(3) is use</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>#include &lt;stdio.h&gt;
#include &lt;time.h&gt;

srand((unsigned int) time(NULL));
</code></pre></div><p>do the seeding, this turns to be a bad practice. To understand why, you may <a href=https://stackoverflow.com/questions/471248/what-is-ultimately-a-time-t-typedef-to>wrapup a test program</a> like the following:</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#00f>#include</span> <span style=color:#00f>&lt;time.h&gt;</span><span style=color:#00f>
</span><span style=color:#00f></span>
<span style=color:#2b91af>int</span> main(<span style=color:#2b91af>void</span>)
{
    time_t a;
    <span style=color:#00f>return</span> 0;
}
</code></pre></div><p>And do the macro-expansion(replace with your favorite C compiler)</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ gcc -E test.c | grep time_t
</code></pre></div><p>You would see the following output</p>
<blockquote>
<p>typedef long int __time_t;</p>
</blockquote>
<blockquote>
<p># 1 &ldquo;/usr/include/bits/types/time_t.h&rdquo; 1 3 4</p>
</blockquote>
<blockquote>
<p>typedef __time_t time_t;</p>
</blockquote>
<p>See, the parameter of srand(3) is typed unsigned int, yet the return value of time(2) is time_t, which is typedef of long int.</p>
<p>There may precision loss over higher bits(if long sized 64-bits), though won&rsquo;t be a big deal, the higher 32-bits usually invariant in considerably timespan.</p>
<p>The issue is the time(2) itself, it return time scaled in seconds, when you bump two generators within one second, you&rsquo;re fairy likely get the same seed.</p>
<p>In other words, the time(2) is coarse-grained over subsecond-level seeding.</p>
<p> </p>
<p>There&rsquo;re many ways to get a better seed</p>
<h3 id=1-incomplete-time-hash>1. Incomplete time hash</h3>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#2b91af>unsigned</span> <span style=color:#2b91af>int</span> time_seed(<span style=color:#2b91af>void</span>)
{
    time_t now = time(NULL);
    <span style=color:#2b91af>unsigned</span> <span style=color:#2b91af>char</span> *p = (<span style=color:#2b91af>unsigned</span> <span style=color:#2b91af>char</span> *) &amp;now;
    <span style=color:#2b91af>unsigned</span> <span style=color:#2b91af>int</span> seed = 0;

    <span style=color:#00f>for</span> (size_t i = 0; i &lt; <span style=color:#00f>sizeof</span>(now); i++)
        seed = seed * (UCHAR_MAX + 2U) + p[i];

    <span style=color:#00f>return</span> seed;
}
</code></pre></div><p>This solution give by <a href=http://www.eternallyconfuzzled.com/arts/jsw_art_rand.aspx>Julienne Walker</a>, yet it turns out incomplete in subsecond-level.</p>
<p>Still produce the same value within a second, though it&rsquo;s hashed.</p>
<p> </p>
<h3 id=2-predictable-entropy>2. Predictable entropy</h3>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#2b91af>int</span> seed = (<span style=color:#2b91af>int</span>) time(NULL) % getpid() + getppid();
</code></pre></div><p>This solution give by <a href=https://www.astro.umd.edu/~ricotti/NEWWEB/teaching/ASTR415/>Massimo Ricotti</a> in his Astronomy class. (awe)</p>
<p>Still subsecond-level precision, yet it works pretty fine if you bear this in mind, especially in multithreading environment.</p>
<p>If you scrutinize this in deep, you&rsquo;ll find the pid may restricted by system configuration.</p>
<p>Taking Linux as an example, the default maximum pid can be found at <em>/proc/sys/kernel/pid_max</em></p>
<blockquote>
<p>/proc/sys/kernel/pid_max (since Linux 2.5.34)</p>
</blockquote>
<blockquote>
<p>This file specifies the value at which PIDs wrap around (i.e., the value in</p>
</blockquote>
<blockquote>
<p>this file is one greater than the maximum PID). PIDs greater than this value</p>
</blockquote>
<blockquote>
<p>are not allocated; thus, the value in this file also acts as a system-wide</p>
</blockquote>
<blockquote>
<p>limit on the total number of processes and threads. The default value for</p>
</blockquote>
<blockquote>
<p>this file, 32768, results in the same range of PIDs as on earlier kernels. On</p>
</blockquote>
<blockquote>
<p>32-bit platforms, 32768 is the maximum value for pid_max. On 64-bit systems,</p>
</blockquote>
<blockquote>
<p>pid_max can be set to any value up to 2^22 (PID_MAX_LIMIT, approximately 4</p>
</blockquote>
<blockquote>
<p>million).</p>
</blockquote>
<p>In 32-bits system, the result cannnot exceed 2 * 32768, which sharply restricted the seed range.</p>
<p>FreeBSD define its <a href="http://fxr.watson.org/fxr/source/sys/proc.h?v=FREEBSD11;im=3#L807">maximum pid</a>(99999 by initial) as macro, seems untunable if compiled.</p>
<p><em>P.S.</em> most UNIX-like systems restricted their default pid range in ten-thousand level(stay backward compatible?), <a href=https://unix.stackexchange.com/questions/16883/what-is-the-maximum-value-of-the-process-id/316499#316499>FYI</a>.</p>
<p>And since the monotonic time is linearly increased, the pid may very likely to follow the same pattern.</p>
<p>Thus the seed is predictable in some ways.</p>
<p> </p>
<h3 id=3-too-much-randomness>3. Too much randomness</h3>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#00f>#include</span> <span style=color:#00f>&lt;time.h&gt;</span><span style=color:#00f>
</span><span style=color:#00f>#include</span> <span style=color:#00f>&lt;unistd.h&gt;</span><span style=color:#00f>
</span><span style=color:#00f>#include</span> <span style=color:#00f>&lt;stdlib.h&gt;</span><span style=color:#00f>
</span><span style=color:#00f>#include</span> <span style=color:#00f>&lt;sys/time.h&gt;</span><span style=color:#00f>
</span><span style=color:#00f></span>
<span style=color:#2b91af>void</span> junk_srandom(<span style=color:#2b91af>void</span>)
{
    <span style=color:#00f>struct</span> timeval tv;
    <span style=color:#2b91af>unsigned</span> <span style=color:#2b91af>long</span> junk; <span style=color:green>/* XXX left uninitialized on purpose */</span>
 
    gettimeofday(&amp;tv, NULL);
    srandom((getpid() &lt;&lt; 16) ^ tv.tv_sec ^ tv.tv_usec ^ junk);
}
</code></pre></div><p>This solution give us sub-microsecond level precision seed, sounds great!</p>
<p>Yet it leaves undefined behaviour of using uninitialized data. Many compilers will ignored the entire translate unit(in this case, the entire expression) by default or by optimization flags.</p>
<p>Compile above code and objdump it</p>
<p><strong><a href=https://godbolt.org/g/HL5tTv>x86-64 gcc 7.3 -O0 flag</a></strong></p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm>junk_srandom:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 32
        lea     rax, [rbp-32]
        mov     esi, 0
        mov     rdi, rax
        call    gettimeofday
        call    getpid
        sal     eax, 16
        mov     edx, eax
        mov     rax, QWORD PTR [rbp-32]     <span style=color:green># tv.tv_sec
</span><span style=color:green></span>        xor     edx, eax
        mov     rax, QWORD PTR [rbp-24]     <span style=color:green># tv.tv_usec
</span><span style=color:green></span>        xor     eax, edx
        mov     edx, eax
        mov     rax, QWORD PTR [rbp-8]      <span style=color:green># junk
</span><span style=color:green></span>        xor     eax, edx
        mov     edi, eax
        call    srandom
        nop
        leave
        ret
</code></pre></div><p><strong><a href=https://godbolt.org/g/zG3MhF>x86-64 gcc 7.3 -O1 flag</a></strong></p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-asm data-lang=asm>junk_srandom:
        sub     rsp, 24
        mov     esi, 0
        mov     rdi, rsp
        call    gettimeofday
        call    getpid
        mov     rdi, QWORD PTR [rsp<span>+</span>8]      <span style=color:green># tv.tv_usec
</span><span style=color:green></span>        xor     edi, DWORD PTR [rsp]        <span style=color:green># tv.tv_sec
</span><span style=color:green></span>        sal     eax, 16
        xor     edi, eax
        call    srandom
        add     rsp, 24
        ret
</code></pre></div><p>You&rsquo;ll notice entire <em>junk</em> variable optimized out(more specifically, the GCC threat it as zero), since its behaviour is undefined. You&rsquo;d better to avoid to use this solution, it&rsquo;s extremely dangerous.</p>
<p>Yet with <a href=https://godbolt.org/g/B1xkMN>minimal remedy</a>, we can bring it back to life.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-fallback data-lang=fallback>#include &lt;time.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;
#include &lt;sys/time.h&gt;

void loselose_srand(void)
{
    struct timeval tv;
    unsigned long junk = 0xdeadbeef;    /* XXX  initialized for prevent from optimized out */
    uintptr_t p = (uintptr_t) &amp;junk;
    //uintptr_t p = (uintptr_t) (const char[]){};

    gettimeofday(&amp;tv, NULL);
    /*
     * Higher bits of an address may have massive 1s  which may pollute the entire seed
     *  cases likely happen in 64-bits  which padding the higher bits
     */
    srand(((getpid() + getppid()) &lt;&lt; 16) ^ tv.tv_sec ^ tv.tv_usec ^ (p &amp; 0xffff00));
}
</code></pre></div><p>This benifits from the <a href=https://en.wikipedia.org/wiki/Address_space_layout_randomization>ASLR</a> technique, which sightly deviated from original junk_srandom().</p>
<p>If ASLR not available in your system, you may replace it with clock(3), which is processor time.</p>
<p> </p>
<p>Nanosecond level seeding seems overkill, pasted here in case you need it.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#00f>#include</span> <span style=color:#00f>&lt;time.h&gt;</span><span style=color:#00f>
</span><span style=color:#00f></span>
<span style=color:#00f>struct</span> timespec ts;
clock_gettime(CLOCK_REALTIME, &amp;ts);
</code></pre></div><p> </p>
<h2 id=random3-and-srandom3>random(3) and srandom(3)</h2>
<p>This pair sourced POSIX, fixed several flaws mentioned above.</p>
<p>As <a href=http://pubs.opengroup.org/onlinepubs/9699919799/functions/srandom.html>the specification</a> states,</p>
<blockquote>
<p>The random() function shall use a non-linear additive feedback random-number generator employing a default state array size of 31 long integers to return successive pseudo-random numbers in the range from 0 to 2^31-1. The period of this random-number generator is approximately 16 x (2^31-1). The size of the state array determines the period of the random-number generator. Increasing the state array size shall increase the period.</p>
</blockquote>
<blockquote>
<p>With 256 bytes of state information, the period of the random-number generator shall be greater than 2^69.</p>
</blockquote>
<p>The range and period is enough for general-purpose. You still need a better seed for srandom(3) though, and since its argument typed unsigned int, the merely time(NULL) still provides subsecond level seeding.</p>
<p> </p>
<h2 id=conclusion>Conclusion</h2>
<p>Random number is a complex topic, maybe it&rsquo;s unusual for you to use random number, yet once you got any chance, do not misuse the basic random functionalities, even you don&rsquo;t need sounding randomness. When the randomness is critical(say, you&rsquo;re devloping a cryptographic hash algorithm), do NOT pursue rand(3) or srand(3), they&rsquo;re terrible. Instead, develop one from scratch, or using state-of-the-art PRNG like <a href=https://metacpan.org/release/Math-Random-TT800>TT800</a> or the <a href=https://en.wikipedia.org/wiki/Mersenne_Twister>Mersenne Twister</a>.</p>
<p> </p>
<h2 id=references><em>References</em></h2>
<blockquote>
<p><a href=https://wiki.sei.cmu.edu/confluence/display/c/EXP33-C.+Do+not+read+uninitialized+memory>EXP33-C. Do not read uninitialized memory</a></p>
<p><a href=https://wiki.sei.cmu.edu/confluence/display/c/MSC30-C.+Do+not+use+the+rand%28%29+function+for+generating+pseudorandom+numbers>MSC30-C. Do not use the rand() function for generating pseudorandom numbers</a></p>
<p><a href=https://wiki.sei.cmu.edu/confluence/display/c/MSC32-C.+Properly+seed+pseudorandom+number+generators>MSC32-C. Properly seed pseudorandom number generators</a></p>
<p><a href=http://www.eternallyconfuzzled.com/arts/jsw_art_rand.aspx>Using rand() (C/C++): Advice for the C standard library&rsquo;s rand() function.</a></p>
<p><a href=https://www.astro.umd.edu/~ricotti/NEWWEB/teaching/ASTR415/class12.pdf>Random numbers and cryptography</a></p>
<p><a href=https://kqueue.org/blog/2012/06/25/more-randomness-or-less/>More randomness or less</a></p>
<p><a href=https://godbolt.org>Compiler Explorer</a></p>
</blockquote>
</div>
<div class=tags>
</div></div>
<script src=https://utteranc.es/client.js repo=leiless/blog issue-term=pathname label=comment theme=github-light crossorigin=anonymous async></script>
</div>
<div class="footer wrapper">
<nav class=nav>
<div>2021 Released under <a href=https://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY-NC-SA 4.0</a> license | <a href=https://github.com/knadh/hugo-ink>Ink</a> theme on <a href=https://gohugo.io>Hugo</a></div>
</nav>
</div>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga('create','G-RMJ7KLHXH8','auto'),ga('send','pageview'))</script>
<script async src=https://www.google-analytics.com/analytics.js></script>
<script>feather.replace()</script>
</body>
</html>